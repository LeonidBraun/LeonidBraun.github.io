<!DOCTYPE html>
<html>

<head>
  <title>Accelerometer Ball</title>
</head>

<body>
  <canvas id="canvas" style="border:1px solid #d3d3d3;"></canvas>
  <script>
    var canvas = document.getElementById('canvas');
    canvas.width = 500;
    canvas.height = 500;
    var context = canvas.getContext('2d');
    // Set the initial position and velocity of the ball
    var gx = 0.;
    var gy = 0.;

    // Capture the accelerometer and gyroscope data
    window.addEventListener('devicemotion', function (event) {
      gx = -event.accelerationIncludingGravity.x;
      //ball.ax = -event.acceleration.x;
      gy = event.accelerationIncludingGravity.y;
    });
    // window.addEventListener('deviceorientation', function(event) {
    // ball.vx += event.gamma / 10;
    // ball.vy += event.beta / 10;
    // });

    var x = [];
    var y = [];
    var vx = [];
    var vy = [];
    var ax = [];
    var ay = [];


    const m = canvas.height / 2;

    N = 30
    for (let i = 0; i < N; i++) {
      x.push(m + 0.4 * m * Math.cos(2 * Math.PI * i / N));
      y.push(m + 0.4 * m * Math.sin(2 * Math.PI * i / N));
      vx.push(0 * m * Math.sin(2 * Math.PI * i / N) - 0.2 * m);
      vy.push(-0 * m * Math.cos(2 * Math.PI * i / N) - 0.1 * m);
      ax.push(0.);
      ay.push(0.);
    }



    // Update the position of the ball on the canvas
    var last_time = null;
    function update(time) {
      if (!last_time) {
        last_time = time;
        requestAnimationFrame(update);
      }
      var dt = 1. * (time - last_time) / 1000.;
      last_time = time;
      // Apply the velocity to the position

      for (let i = 0; i < N; i++) {
        const nx = x[(i + 1) % N];
        const ny = y[(i + 1) % N];
        const px = x[(i + N - 1) % N];
        const py = y[(i + N - 1) % N];

        const l0 = 0.1 * m;
        const l_f = -1000.;
        // const P =

        ax[i] = 0.;
        ay[i] = 0.;

        var dx = nx - x[i];
        var dy = ny - y[i];
        var l = Math.sqrt(dx * dx + dy * dy);
        ax[i] += l_f * (l0 - l) * dx / l + dy;
        ay[i] += l_f * (l0 - l) * dy / l - dx;

        var dx = px - x[i];
        var dy = py - y[i];
        var l = Math.sqrt(dx * dx + dy * dy);
        ax[i] += l_f * (l0 - l) * dx / l - dy;
        ay[i] += l_f * (l0 - l) * dy / l + dx;
      }

      for (let i = 0; i < N; i++) {

        vx[i] += dt * (ax[i]);
        vy[i] += dt * (ay[i]);
        x[i] += dt * vx[i] + dt * dt * ax[i];
        y[i] += dt * vy[i] + dt * dt * ay[i];
        // Keep the ball within the canvas bounds
        if (x[i] < 0) {
          x[i] = 0;
          vx[i] = -0.9 * vx[i];
        } else if (x[i] > canvas.width) {
          x[i] = canvas.width;
          vx[i] = -0.9 * vx[i];
        }
        if (y[i] < 0) {
          y[i] = 0;
          vy[i] = -0.9 * vy[i];
        } else if (y[i] > canvas.height) {
          y[i] = canvas.height;
          vy[i] = -0.9 * vy[i];
        }
        // Clear the canvas and redraw the ball
        // context.beginPath();
        // context.arc(x[i], y[i], 10, 0, Math.PI * 2);
        // context.fill();
        // // context.beginPath();
        // context.moveTo(x[i], y[i]);
        // context.lineTo(nx, ny);
      }

      context.clearRect(0, 0, canvas.width, canvas.height);
      context.beginPath();
      context.fillStyle = 'grey';
      context.moveTo(x[N], y[N]);
      for (let i = 0; i < N; i++) {
        context.lineTo(x[i], y[i]);
      }
      // context.closePath();
      context.fill();
      for (let i = 0; i < N; i++) {
        context.beginPath();
        context.fillStyle = 'black';
        context.arc(x[i], y[i], 4, 0, Math.PI * 2);
        context.fill();
      }
      // context.closePath();
      // context.fill();
      // Request the next frame
      requestAnimationFrame(update);
    }
    // Start the animation loop
    requestAnimationFrame(update);
  </script>
</body>

</html>